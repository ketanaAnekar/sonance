<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<link rel="icon" type="image/png" sizes="32x32" href="images/sonanceFav1.png">
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Sonance</title>
<style>
  :root { color-scheme: dark; }
  * { box-sizing: border-box }
  html,body { margin:0; height:100%; background:#000; color:#e7eef7; font-family: system-ui, sans-serif; }

  #libraryView { width:100%; height:100%; }
  #p5-holder { position: fixed; inset: 0; }

  #siteTitle{
    position:fixed; top:14px; left:50%; transform:translateX(-50%);
    z-index:5; pointer-events:none;
    margin:0; font-weight:800; letter-spacing:0.32em; text-transform:uppercase;
    font-size: clamp(18px, 2.8vw, 28px);
    color:#fff; opacity:1; text-shadow:none;
  }

  #hintBar {
    position:fixed; left:50%; transform:translateX(-50%);
    bottom:18px; background:rgba(13,25,43,.75); border:1px solid #1b2b42;
    padding:6px 10px; border-radius:10px; font-size:12px; opacity:.9;
    pointer-events:none; z-index:3; display:none;
  }
</style>
</head>
<body>
<h1 id="siteTitle">SONANCE</h1>
<section id="libraryView"><div id="p5-holder"></div></section>
<div id="hintBar">Tap once to enable sound</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
<script>
/* ----------------------- Data ----------------------- */
let LIB = { songs: [] };
async function loadLibrary(){ const res = await fetch('library.json'); LIB = await res.json(); }

/* ----- peaks for circle motion (visual only) ----- */
const DecodeAC = new (window.AudioContext || window.webkitAudioContext)();
function computePeaks(buffer, bins=360){
  const ch = buffer.getChannelData(0), len = ch.length, step = Math.max(1, Math.floor(len / bins));
  const out = new Array(bins);
  for (let i=0;i<bins;i++){
    let min= 1, max=-1, start = i*step, end = Math.min(len, start+step);
    for (let j=start;j<end;j++){ const v=ch[j]; if(v<min)min=v; if(v>max)max=v; }
    out[i] = (Math.abs(min)+Math.abs(max)) * 0.5;
  }
  return out;
}
async function decodePeaks(url, bins=360){
  try {
    const buf = await (await fetch(url, { cache: 'no-store' })).arrayBuffer();
    const audioBuf = await DecodeAC.decodeAudioData(buf);
    return computePeaks(audioBuf, bins);
  } catch { return null; }
}
function placeholderPeaks(n=360){
  const out = new Array(n);
  for (let i=0;i<n;i++) out[i] = 0.25 + 0.15*Math.sin(i*0.22) + 0.08*Math.sin(i*0.67 + 1.2);
  return out;
}

/* ---------- palettes & knobs ---------- */
const COOL_PALETTE = [165,170,176,182,188,195,202,208,214,220];
const ringHue = (baseHue, ringIndex, ringCount)=> (baseHue - 24) + (48 * (ringIndex/(ringCount-1)));

const STROKE_RANGE   = [8, 20];
const OPACITY_RANGE  = [0.62, 0.96];
const RING_RANGE     = [8, 12];
const FILL_PATTERN   = [2, 3];

/* global color softener (brightness â†“, keep alpha as-is) */
const COLOR_TWEAK = {
  SAT_K:   0.95,
  LIGHT_K: 0.90,
  ALPHA_K: 1.00   // keep original opacities
};
const tS = (s) => s * COLOR_TWEAK.SAT_K;
const tL = (l) => l * COLOR_TWEAK.LIGHT_K;
const tA = (a) => a * COLOR_TWEAK.ALPHA_K;
/* === Grid === */
const GRID_CFG = { marginPct: 0.04, gutterPct: 0.03, minR: 56, fillK: 0.62, bottomPadPct: 0.05 };
const GRID_RC  = { rows: 3, cols: 5 };

/* === Orbit image config === */
const IMG_CFG = { sizeMin: 160, sizeMax: 320, sizeVW: 0.24, cornerRatio: 0.16, drawScale: 1.06 };
const ORBIT_CFG = { ringBase: 1.98, ringGrow: 0.42, overlapPx: -8 };

/* === Subtle pixel overlay config === */
const OVERLAY_CFG = { enabled: true, cell: 26, alpha: 0.12, sizeFactor: 0.20 };

let previews = [];
let libSketch;

/* -------- Index-based circle styling -------- */
const CIRCLE_STYLE = [
  { hue: 285, sat: 1.00, alpha: 0.90 }, null,
  { hue:   0, sat: 0.06, alpha: 0.40 }, { hue: 35, sat: 1.00, alpha: 0.78 },
  { hue: 150, sat: 1.00, alpha: 0.67 }, { hue: 350, sat: 1.00, alpha: 0.83 },
  { hue:  54, sat: 1.00, alpha: 0.50 }, { hue: 300, sat: 1.00, alpha: 0.98 },
  { hue: 125, sat: 1.00, alpha: 0.86 }, null,
  { hue:  40, sat: 1.00, alpha: 0.78 }, { hue: 20, sat: 1.00, alpha: 0.80 },
  { hue:   0, sat: 1.00, alpha: 0.56 }, { hue: 18, sat: 0.85, alpha: 1.00 },
  null
];
const styleForIndex = (i)=> (i>=0 && i<CIRCLE_STYLE.length) ? CIRCLE_STYLE[i] : null;

/* --------- Per-circle sprite alpha ranges --------- */
const SPRITE_ALPHA_RANGES = [
  [0.70,0.75], [0.65,0.70], [0.10,0.18], [0.55,0.58], [0.58,0.62],
  [0.68,0.72], [0.65,0.72], [0.95,0.98], [0.82,0.86], [0.72,0.78],
  [0.80,0.87], [0.86,0.90], [0.30,0.40], [0.96,1.00], [0.53,0.60]
];

/* ---- Labels for each circle (row-major 3x5) ---- */
const LABELS = [
  { title: 'fresh',              year: '2022' },
  { title: 'CIS',                year: '2021' },
  { title: 'way back when',      year: '2008' },
  { title: 'indie pop',          year: '2019' },
  { title: 'rebel',              year: '2020' },
  { title: 'tamed',              year: '2023' },
  { title: '#ravergurl',         year: '2017' },
  { title: 'juniors',            year: '2025' },
  { title: 'knowing d <3',       year: '2024' },
  { title: 'pre nyc',            year: '2022' },
  { title: 'myfirstspring',      year: '2023' },
  { title: 'o blr', year: '2023' },
  { title: 'harry0102',          year: '2016' },
  { title: 'ny HEAT',            year: '2025' },
  { title: 'merica',             year: '2021' }
];
const MATCH_LABEL_TO_HUE = true;

/* helpers */
const rand = (a,b)=> a + Math.random()*(b-a);
const randi = (a,b)=> Math.floor(rand(a,b+1));
const coolHue = i => COOL_PALETTE[i % COOL_PALETTE.length];
const clamp01 = v => v<0?0:v>1?1:v;
const smooth = t => t<0 ? 0 : t>1 ? 1 : t*t*(3-2*t);
const lerp = (a,b,t)=>a+(b-a)*t;

/* -------- Title-safe + bottom-safe grid ---------- */
function titleSafeTop(){
  const el = document.getElementById('siteTitle');
  if (!el) return 0;
  const r = el.getBoundingClientRect();
  return r.height + 18;
}
function chooseBestGrid(n, W, H, safeTop){
  const rows = GRID_RC.rows, cols = GRID_RC.cols;
  const m = Math.min(W,H) * GRID_CFG.marginPct;
  const g = Math.min(W,H) * GRID_CFG.gutterPct;
  const bpad = Math.min(W,H) * GRID_CFG.bottomPadPct;

  const usableH = Math.max(60, H - safeTop - m - bpad);
  const cellW = (W - 2*m - (cols-1)*g) / cols;
  const cellH = (usableH - (rows-1)*g) / rows;

  const glowPad = 6;
  const R = Math.max(GRID_CFG.minR, Math.min(cellW, cellH) * GRID_CFG.fillK) - glowPad;

  return { rows, cols, cellW, cellH, R, m, g, safeTop, bpad };
}
function layoutPreviewsAuto(){
  const holder = document.getElementById('p5-holder');
  const r = holder.getBoundingClientRect();
  const W = r.width, H = r.height;
  const safeTop = titleSafeTop();
  const grid = chooseBestGrid(previews.length, W, H, safeTop);

  previews.forEach((p, i) => {
    const c = i % grid.cols;
    const rr = Math.floor(i / grid.cols);
    p.row = rr; p.col = c;
    p.homeX = grid.m + c * (grid.cellW + grid.g) + grid.cellW/2;
    p.homeY = grid.safeTop + grid.m + rr * (grid.cellH + grid.g) + grid.cellH/2;
    p.R = grid.R;

    p.offX = p.homeX + (p.homeX < W/2 ? -W*0.9 : W*0.9);
    p.offY = p.homeY + (p.homeY < H/2 ? -H*0.9 : H*0.9);
  });

  if (!reveal.armed) {
    reveal.order = [];
    for (let rr=0; rr<grid.rows; rr++){
      const rowIdxs = [];
      for (let c=0; c<grid.cols; c++){
        const idx = rr*grid.cols + c;
        if (idx < previews.length) rowIdxs.push(idx);
      }
      if (rr % 2 === 1) rowIdxs.reverse();
      reveal.order.push(...rowIdxs);
    }
    reveal.when.clear();
    reveal.start = performance.now();
    reveal.order.forEach((idx,i)=> reveal.when.set(idx, reveal.start + i*reveal.gap));
    reveal.armed = true;
  }
}

/* -------- Build previews -------- */
async function buildPreviews() {
  previews = (LIB.songs || []).map((song, i)=>{
    const sty = styleForIndex(i);
    const hueBase = Number.isFinite(sty?.hue)
      ? ((sty.hue % 360) + 360) % 360
      : (coolHue(randi(0, COOL_PALETTE.length-1)) + rand(-10,10) + 360) % 360;

    const strokeMin = rand(STROKE_RANGE[0], Math.min(14, STROKE_RANGE[1]-2));
    const strokeMax = rand(Math.max(strokeMin+2, 14), STROKE_RANGE[1]);
    const opMin = rand(OPACITY_RANGE[0], 0.78);
    const opMax = rand(0.90, OPACITY_RANGE[1]);
    const rings  = randi(RING_RANGE[0], RING_RANGE[1]);
    const fillStep   = randi(FILL_PATTERN[0], FILL_PATTERN[1]);
    const fillOffset = randi(0, fillStep-1);

    return {
      idx: i,
      song,
      peaks: placeholderPeaks(360),
      homeX:0, homeY:0, R:110,
      hue: hueBase, sat: Number.isFinite(sty?.sat) ? clamp01(sty.sat) : 1.0,
      alphaScale: Number.isFinite(sty?.alpha) ? clamp01(sty.alpha) : 1.0,
      hover:0, env: [], seed: Math.random()*1000, rings,
      strokeMin, strokeMax, opMin, opMax, fillStep, fillOffset,
      offX:0, offY:0,
      _sprites: null, _audio: null
    };
  });

  layoutPreviewsAuto();

  await Promise.allSettled(previews.map(async (p)=>{
    const peaks = await decodePeaks(p.song.audio, 360);
    if (peaks) p.peaks = peaks;
  }));
}

/* -------- Background -------- */
function drawLibraryBG(p){
  const ctx = p.drawingContext;
  ctx.save(); ctx.globalCompositeOperation = 'source-over';
  ctx.fillStyle = '#000'; ctx.fillRect(0,0,p.width,p.height); ctx.restore();
}

/* -------- circle helpers -------- */
function sampleAt(peaks, pos){
  const N = peaks.length; if (!N) return 0.0;
  const i0 = Math.floor(pos)%N; const i1 = (i0+1)%N;
  const f = pos - Math.floor(pos);
  return peaks[i0]*(1-f) + peaks[i1]*f;
}
function smoothSample(peaks, pos){
  const w = [0.06, 0.24, 0.40, 0.24, 0.06];
  return w[0]*sampleAt(peaks, pos-2) + w[1]*sampleAt(peaks, pos-1) +
         w[2]*sampleAt(peaks, pos  ) + w[3]*sampleAt(peaks, pos+1) +
         w[4]*sampleAt(peaks, pos+2);
}
function followEnv(prev, target, dt, ATTACK, RELEASE){
  const tau = (target > prev) ? ATTACK : RELEASE;
  const c = Math.exp(-dt / Math.max(1e-4, tau));
  return target + (prev - target)*c;
}

/* ---- CONCENTRIC CIRCLES (dimmed, alpha-stable, no white flash) ---- */
/* ---- CONCENTRIC CIRCLES (no-white, low-sat safe) ---- */
function drawConcentric(p, prev, baseR, t, hueBase){
  const ctx = p.drawingContext;

  const rings = prev.rings;
  if (prev.env.length !== rings) prev.env = new Array(rings).fill(0);

  const PEAK_SCROLL_SPEED = 36, ATTACK = 0.08, RELEASE = 0.35;
  const posBase = t * PEAK_SCROLL_SPEED;
  const stride  = (prev.peaks.length || 360) / (rings + 1);
  const dt = p.deltaTime / 1000;

  const S = (prev.sat ?? 1);
  const A = (prev.alphaScale ?? 1);

  // Low saturation (nearly gray) -> darker caps + no center pulse
  const LOW_SAT = S < 0.15;
  const EDGE_L  = LOW_SAT ? 0.40 : 0.55;
  const RIM_L   = LOW_SAT ? 0.45 : 0.65;
  const GLOW_L  = LOW_SAT ? 0.20 : 0.38;

  // Subtle aura (no 'screen' so it won't blow out)
  ctx.save();
  ctx.globalCompositeOperation = 'source-over';
  p.noStroke();
  p.fill(hueBase, S, LOW_SAT ? 0.14 : 0.20, 0.12 * A);
  p.circle(0, 0, baseR * 2.0);
  ctx.restore();

  for (let i = 0; i < rings; i++){
    const hue    = ringHue(hueBase, i, rings);
    const target = smoothSample(prev.peaks, posBase + i * stride);
    prev.env[i]  = followEnv(prev.env[i], target, dt, ATTACK, RELEASE);

    const pulse = 1 + (0.22 + 0.60 * prev.env[i]) * 0.28;
    const r     = baseR * (0.36 + i * (0.62 / rings)) * pulse;

    const strokeBase = p.map(p.noise(prev.seed + 10 + i*0.37 + t*0.35), 0, 1, prev.opMin, prev.opMax);
    const fillBase   = p.map(p.noise(prev.seed + 20 + i*0.41 + t*0.32), 0, 1, prev.opMin, prev.opMax);
    const strokeA    = p.constrain(strokeBase * (0.90 + 0.40 * prev.env[i]), prev.opMin, prev.opMax) * A;
    const fillA      = p.constrain(fillBase   * (0.85 + 0.45 * prev.env[i]), prev.opMin, prev.opMax) * A;

    // Gentle inner glow
    ctx.save();
    ctx.globalCompositeOperation = 'source-over';
    ctx.filter = 'blur(3px)';
    p.noStroke();
    p.fill(hue, S, GLOW_L, fillA * 0.28);
    p.circle(0, 0, r * 2 * 0.74);
    ctx.restore();

    // Colored edge
    ctx.save();
    ctx.globalCompositeOperation = 'source-over';
    ctx.filter = 'none';
    p.noFill();
    const w = p.map(p.noise(prev.seed + 100 + i*0.7 + t*0.3), 0, 1, prev.strokeMin, prev.strokeMax);
    p.stroke(hue, S, EDGE_L, Math.min(1, strokeA));
    p.strokeWeight(w);
    p.circle(0, 0, r * 2);
    ctx.restore();

    // Soft rim (subtle)
    ctx.save();
    ctx.globalCompositeOperation = 'source-over';
    p.stroke(hue, S, RIM_L, strokeA * 0.20);
    p.strokeWeight(Math.max(1, w * 0.55));
    p.circle(0, 0, r * 2 * 0.92);
    ctx.restore();
  }

  // Center pulse: only for saturated colors, and kept dark/subtle
  if (!LOW_SAT){
    const avgEnv = prev.env.reduce((x,y)=>x+y,0)/rings;
    ctx.save();
    ctx.globalCompositeOperation = 'source-over';
    p.noStroke();
    p.fill(hueBase, S, 0.28, 0.14 * A);
    p.circle(0, 0, baseR * (0.30 + 0.35 * avgEnv));
    p.fill(hueBase, S, 0.34, 0.10 * A);
    p.circle(0, 0, baseR * (0.20 + 0.22 * avgEnv));
    ctx.restore();
  }
}


/* ---------- Audio ---------- */
const AC = new (window.AudioContext || window.webkitAudioContext)();
const hintBar = document.getElementById('hintBar');
function showHint(){ if (AC.state === 'suspended') hintBar.style.display='block'; }
function hideHint(){ hintBar.style.display='none'; }
addEventListener('pointerdown', async ()=>{ try { await AC.resume(); } finally{ hideHint(); } }, { passive:true });

async function ensureAudioFor(preview){
  if (preview._audio) return preview._audio;
  const audio = new Audio(preview.song.audio);
  audio.crossOrigin = 'anonymous';
  audio.preload = 'metadata';

  const src = AC.createMediaElementSource(audio);
  const analyser = AC.createAnalyser(); analyser.fftSize = 1024;
  const gain = AC.createGain(); gain.gain.value = 0.0;

  src.connect(analyser); analyser.connect(gain); gain.connect(AC.destination);
  const data = new Uint8Array(analyser.frequencyBinCount);

  preview._audio = { audio, src, analyser, gain, data };
  showHint();
  return preview._audio;
}

/* ---------- Uniform square sprites ---------- */
function makeSquareSprite(bmp, meta){
  const side = Math.round(Math.min(IMG_CFG.sizeMax, Math.max(IMG_CFG.sizeMin, innerWidth * IMG_CFG.sizeVW)));
  const srcW = bmp.width, srcH = bmp.height;
  const s = Math.min(srcW, srcH);
  const sx = Math.floor((srcW - s) / 2);
  const sy = Math.floor((srcH - s) / 2);

  const off = document.createElement('canvas'); off.width = side; off.height = side;
  const oc = off.getContext('2d', { willReadFrequently:true });
  oc.imageSmoothingEnabled = true; oc.imageSmoothingQuality = 'high';
  oc.drawImage(bmp, sx, sy, s, s, 0, 0, side, side);

  const sample = oc.getImageData(0,0,side,side).data;
  const radius = Math.max(8, Math.floor(side * IMG_CFG.cornerRatio));

  return { meta, size: side, radius, off, sample, x:0, y:0, alpha: 1.0 };
}
function loadBitmap(imgMeta){
  return new Promise((resolve, reject)=>{
    // build a robust absolute URL from whatever came in
    const url = new URL(imgMeta.src, location.href).href;

    const img = new Image();
    // only set crossOrigin if itâ€™s not the same origin (prevents some local dev issues)
    if (new URL(url).origin !== location.origin) {
      img.crossOrigin = 'anonymous';
    }

    img.onload  = async () => {
      try { resolve(await createImageBitmap(img)); }
      catch (e) { reject(new Error('createImageBitmap failed for ' + url)); }
    };
    img.onerror = (e) => reject(new Error('Image failed: ' + url));
    img.src = url;
  });
}
function getSpriteAlphaForCircleIndex(i){
  const r = SPRITE_ALPHA_RANGES[i] || [0.90,0.90];
  return rand(r[0], r[1]);
}
async function ensureSpritesFor(preview){
  if (preview._sprites || !preview.song?.images) return;
  const results = await Promise.allSettled(preview.song.images.map(loadBitmap));
  const items = preview.song.images
    .map((meta,i)=>({ meta, bmp: results[i].status === 'fulfilled' ? results[i].value : null }))
    .filter(it => it.bmp);
  preview._sprites = items.map(it => { const sp = makeSquareSprite(it.bmp, it.meta); sp.alpha = getSpriteAlphaForCircleIndex(preview.idx); return sp; });
}

/* rounded-rect helper */
function roundRectPath(ctx, x, y, w, h, r){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y,   x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x,   y+h, rr);
  ctx.arcTo(x,   y+h, x,   y,   rr);
  ctx.arcTo(x,   y,   x+w, y,   rr);
  ctx.closePath();
}

function focusCenter(p){ return { cx: p.width * 0.5, cy: p.height * 0.5 }; }

function stopSong(preview, reset=true){
  const A = preview?._audio; if (!A) return;
  A.gain.gain.setTargetAtTime(0.0, AC.currentTime, 0.05);
  try { A.audio.pause(); } catch {}
  if (reset) { try { A.audio.currentTime = 0; } catch {} }
  hideHint();
}

/* ---------------- Reveal + Focus state ---------------- */
let reveal = { order: [], when: new Map(), start: 0, dur: 520, gap: 140, armed: false };
let focus  = { idx: null, t: 0, target: 0 };

/* ------------ Label drawing (centered, no shadow) ----------- */
function drawCircleLabel(p, prev, x, y, tt){
  const L = LABELS[prev.idx]; if (!L) return;
  const a = Math.max(0, Math.min(1, (tt - 0.15) / 0.85));
  const titleSize = Math.max(14, prev.R * 0.26);
  const yearSize  = Math.max(10, prev.R * 0.15);

  const ctx = p.drawingContext; ctx.save(); ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0;
  p.push(); p.textAlign(p.CENTER, p.CENTER); p.noStroke();

  if (MATCH_LABEL_TO_HUE){
    p.fill(prev.hue, tS(0.85), tL(0.70), a);
  } else {
    p.fill(0, 0, tL(1.0), a);
  }
  p.textStyle(p.BOLD);   p.textSize(titleSize); p.text(L.title, x, y - yearSize * 0.6);
  p.textStyle(p.NORMAL); p.textSize(yearSize);  p.text(L.year,  x, y + yearSize * 0.9);

  p.pop(); ctx.restore();
}

/* ------------------------------ p5 sketch ------------------------------ */
function startP5(){
  const holder = document.getElementById('p5-holder');
  const rect = () => holder.getBoundingClientRect();

  libSketch = new p5((p) => {
    p.setup = () => {
      const r = rect();
      p.createCanvas(r.width, r.height, p.P2D).parent(holder);
      p.pixelDensity(1); p.frameRate(60);
      p.colorMode(p.HSL, 360, 1, 1, 1); p.noStroke();
      p.textFont('system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif');
    };
    p.windowResized = () => { const r = rect(); p.resizeCanvas(r.width, r.height); layoutPreviewsAuto(); };

    function currentPosFor(i){
      const tt = smooth(focus.t);
      const prev = previews[i];
      if (focus.idx === null) return { x: prev.homeX, y: prev.homeY };
      if (i === focus.idx){
        const { cx, cy } = focusCenter(p);
        return { x: lerp(prev.homeX, cx, tt), y: lerp(prev.homeY, cy, tt) };
      }
      return { x: lerp(prev.homeX, prev.offX, tt), y: lerp(prev.homeY, prev.offY, tt) };
    }

    p.draw = () => {
      const t = p.millis()/1000; drawLibraryBG(p);
      focus.t += (focus.target - focus.t) * 0.1;
      const tt = smooth(focus.t);
      const ctx = p.drawingContext;

      previews.forEach((prev, i) => {
        const now = performance.now();
        const st  = reveal.when.get(i) ?? reveal.start;
        const rProg = smooth((now - st) / reveal.dur);
        if (rProg <= 0) return;

        const pos = currentPosFor(i);
        const hovering = p.dist(p.mouseX, p.mouseY, pos.x, pos.y) < prev.R*1.05;
        prev.hover = clamp01((prev.hover||0) + (hovering ? 1 : -1)*0.12);
        const idleBreath = 0.015 * Math.sin((t + i*0.37) * 1.2);

        const isFocus = (i === focus.idx);
        const focusScale = isFocus ? (1 + 0.06*tt) : (1 - 0.04*tt);

        const baseR = prev.R * (0.98*focusScale) * (0.35 + 0.65*rProg) * (1 + 0.06*prev.hover + idleBreath);
        const hue   = prev.hue + 4*Math.sin(t*0.35);

        p.push(); p.translate(pos.x, pos.y);
        ctx.globalAlpha = Math.min(1, rProg * (isFocus ? 1 : 1 - 0.10*tt));
        drawConcentric(p, prev, baseR, t, hue);
        ctx.globalAlpha = 1; p.pop();

        if (isFocus){ focus.fx = pos.x; focus.fy = pos.y; }
      });

      if (focus.idx !== null && focus.t > 0.02){
        const prev = previews[focus.idx];
        ensureSpritesFor(prev); ensureAudioFor(prev);

        const sprites = prev._sprites || [];
        const A = prev._audio;

        let vol = 0;
        if (A){
          A.analyser.getByteFrequencyData(A.data);
          const n=A.data.length, low=A.data[0]|0, mid=A.data[(n*0.33)|0]|0, hi=A.data[(n*0.66)|0]|0;
          vol = (low+mid+hi)/3/255;
        }

        const ringR = prev.R * (ORBIT_CFG.ringBase + ORBIT_CFG.ringGrow*tt) + (ORBIT_CFG.overlapPx || 0);
        const N = Math.max(1, sprites.length);
        const base = (t*0.35)% (2*Math.PI);

        let hovered = null;

        sprites.forEach((sp, k) => {
          const ang = base + k * (2*Math.PI / N);
          const s   = tt;

          const x   = focus.fx + Math.cos(ang) * ringR;
          const y   = focus.fy + Math.sin(ang) * ringR;

          const side = sp.size * IMG_CFG.drawScale;
          const w = side, h = side;

          sp.x = x - w/2; sp.y = y - h/2;

          if (libSketch.mouseX>=sp.x && libSketch.mouseX<=sp.x+w && libSketch.mouseY>=sp.y && libSketch.mouseY<=sp.y+h) hovered = sp;

          const ctxL = libSketch.drawingContext;
          ctxL.save();
          ctxL.globalAlpha = Math.max(0, Math.min(1, (0.96 * s) * sp.alpha));
          roundRectPath(ctxL, sp.x, sp.y, w, h, sp.radius);
          ctxL.clip(); ctxL.drawImage(sp.off, sp.x, sp.y, w, h); ctxL.restore();
        });

        if (A){
          const allowHover = (focus.target === 1 && tt > 0.9);
          const wantPlay   = allowHover && !!hovered;
          A.gain.gain.setTargetAtTime(wantPlay ? 1.0 : 0.0, AC.currentTime, 0.05);
          if (wantPlay){ if (AC.state === 'suspended') showHint(); else hideHint(); A.audio.play().catch(()=>{}); }
          else { try { if (!A.audio.paused) A.audio.pause(); } catch {} }
        }

        if (OVERLAY_CFG.enabled && sprites.length){
          const cell = OVERLAY_CFG.cell;
          const ctxE = libSketch.drawingContext; ctxE.save(); ctxE.globalCompositeOperation = 'source-over';
          sprites.forEach((sp)=>{
            const W = Math.floor(sp.size * IMG_CFG.drawScale), H = W, img = sp.sample; if (!img || tt < 0.15) return;
            for (let yy=0; yy<H; yy+=cell){
              for (let xx=0; xx<W; xx+=cell){
                const sx = Math.min(sp.size-1, Math.floor((xx + (cell>>1)) * (sp.size / W)));
                const sy = Math.min(sp.size-1, Math.floor((yy + (cell>>1)) * (sp.size / H)));
                const idx=(sy*sp.size + sx)*4;
                const r=img[idx], g=img[idx+1], b=img[idx+2];
                ctxE.fillStyle = `rgba(${r},${g},${b},${OVERLAY_CFG.alpha * sp.alpha})`;
                const baseS=cell*(0.24 + (r+g+b)/(3*255)*0.36);
                const grow=1 + vol*0.4;
                const s=Math.max(1.5, baseS*OVERLAY_CFG.sizeFactor*grow);
                ctxE.beginPath(); ctxE.arc(sp.x+xx+cell/2, sp.y+yy+cell/2, s*0.35, 0, Math.PI*2); ctxE.fill();
              }
            }
          });
          ctxE.restore();
        }

        drawCircleLabel(p, prev, focus.fx, focus.fy, tt);
      }
    };

    p.mousePressed = () => {
      const wasFocused = focus.idx != null ? previews[focus.idx] : null;

      let clickedIndex = -1;
      for (let i=0; i<previews.length; i++){
        const tt = smooth(focus.t);
        const prev = previews[i];
        let pos;
        if (focus.idx === null) { pos = { x: prev.homeX, y: prev.homeY }; }
        else if (i === focus.idx){ const { cx, cy } = { cx: p.width*0.5, cy: p.height*0.5 }; pos = { x: lerp(prev.homeX, cx, tt), y: lerp(prev.homeY, cy, tt) }; }
        else { pos = { x: lerp(prev.homeX, prev.offX, tt), y: lerp(prev.homeY, prev.offY, tt) }; }
        if (p.dist(p.mouseX, p.mouseY, pos.x, pos.y) < previews[i].R*1.05){ clickedIndex = i; break; }
      }

      if (clickedIndex === -1){
        if (wasFocused){
          stopSong(wasFocused, true);
          focus.target = 0;
          const waitClear = () => { if (focus.t < 0.03) { focus.idx = null; return; } requestAnimationFrame(waitClear); };
          requestAnimationFrame(waitClear);
        }
        return;
      }

      if (clickedIndex === focus.idx){
        stopSong(previews[clickedIndex], true);
        focus.target = 0;
        const waitClear = () => { if (focus.t < 0.03) { focus.idx = null; return; } requestAnimationFrame(waitClear); };
        requestAnimationFrame(waitClear);
        return;
      }

      if (wasFocused) stopSong(wasFocused, true);

      focus.idx = clickedIndex; focus.target = 1;
      ensureSpritesFor(previews[clickedIndex]); ensureAudioFor(previews[clickedIndex]);
    };
  });
}

/* ----------------------- Boot ----------------------- */
(async ()=>{
  startP5();
  await loadLibrary();
  await buildPreviews();
})();
</script>
</body>
</html>
